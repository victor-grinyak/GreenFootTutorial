Глава 4: "Типы данных в языке Java и операции над ними, переменные, массивы" 


Объявление переменных. 


Язык программирования Java является языком со строгой типизацией. Это означает, что все объекты программы (переменные, константы и т.д.) должны быть описаны до первого использования.

Пример объявления переменной: 
	int x = 1;
	int y = 2;

При объявлении переменной, в следующей последовательности указываются:
	- тип данных (в данном примере — int — переменная содержит целое число),
	- имя переменной (в данном примере имена — x и y),
	- начальное значение переменной  или, другими словами,  инициализация переменной. В данном примере переменным x и y присвоены значения 1 и 2.  Однако, это не является обязательным условием при объявлении переменной.

Пример объявления переменных без инициализации:
	int x;
	int y;
После каждой строки при объявлении переменных необходимо ставить точку с запятой «;».

Если нужно объявить несколько переменных одного типа, то это также можно сделать одной строкой, указав имена переменных через запятую.
	int x,y;

Правила именования переменных в java

	1. Имя переменной должно начинаться с буквы (маленькой) и состоять из букв (Unicode) цифр и символа подчеркивания «_». Технически возможно начать имя переменной также с «$» или «_», однако это запрещено соглашением по оформлению кода в Java (Java Code Conventions). Кроме того, символ доллара «$», по соглашению, никогда не используется вообще. В соответствии с соглашением имя переменной должно начинаться именно с маленькой буквы (с заглавной буквы начинаются имена классов). Пробелы при именовании переменных не допускаются.
	2. Имя переменной не должно быть ключевым или зарезервированным словом языка Java.
	3. Имя переменной чувствительно к регистру.  newVariable и newvariable — разные имена.
	4. При выборе имени переменных, следует использовать полные слова вместо загадочных аббревиатур. Это сделает ваш код более удобным для чтения и понимания. Во многих случаях это также сделает ваш код самодокументируемым.
	5. Если выбранное вами имя переменной состоит только из одного слова — запишите его маленькими буквами. Если оно состоит из более чем одного слова, то отделяйте каждое последующее слово в имени переменной заглавной буквой. Например: superCounter, myDomesticAnimal
	6. Если переменная сохраняет постоянное значение, то каждое слово следует писать заглавными буквами и отделять при помощи символа подчеркивания. Пример: static final int NUMBER_OF_HOURS_IN_A_DAY = 24	
	
	
Типы данных.


Введение типов данных является одной из базовых концепций языка Java, заключающейся в том, что при выполнении операции присваивания переменной значения выражения, переменная и выражение должны быть одного типа. 
Множество типов данных языка Java обычно делят на две группы:
	1. Примитивные – primitive
	2. Ссылочные – reference
Ссылочные типы являются объектами. 
Примитивные типы – это скалярные величины. В языках программирования, не являющихся объектно-ориентированными, примитивные типы называют простыми типами.

Примитивные типы данных.

Примитивные типы Java не являются объектами. Всего их восемь, к ним относятся: byte, short, int, long, float, double, char и boolean.

Логический тип

В Java переменные логического типа задаются с помощью ключевого слова boolean и могут иметь лишь одно из двух значений: true или false.
Тип boolean занимает в памяти 8 бит.
B Java значения true и false могут быть присвоены только тем переменным, которые объявлены как boolean, или использоваться в выражениях с булевскими операциями. Например, логическое выражение, которое должно быть истинно, если значение х попадает в интервал
	[x1, x2], 
должно быть записано следующим образом:
	х>=x1 && х<=x2
Чтобы сделать выражение хорошо читаемым, используют скобки
	(х>=x1) && (х<=x2)
	
Пример использования логического типа данных:
	boolean isInRange;
	int x1= 1;
	int x2=5;
	int x=3;
	isInRange = x>x1 && x<x2;
	System.out.println("Внутри диапазона: " +isInRange);
Будет выведено:
	Внутри диапазона: true
	
Целочисленный тип

Целые типы различаются по размеру отведенной для них памяти:
	byte - 8-разрядное целое число
	short - 16-разрядное целое число
	int - 32-разрядное целое число
	long - 64-разрядное целое число
	char - 16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)

Тип		Размер(бит)		Минимальное значение		Максимальное значение
byte		8 			-128				127
short		16			-32768				32767
int		32			-2147483648			2147483647
long		64			-922372036854775808		922372036854775807
char		16			0				65536

Символьный тип

Для работы с символами в Java используется тип данных char, в котором символ представлен в 16-битным значением в Unicode-таблице.
Unicode (Юникод)- это стандарт кодирования символов, который позволяет предоставить знаки всех языков мира. 
Каждый символ представлен двумя байтами, которые позволяют хранить в себе число от нуля до 65535, что и позволяет использовать 65536 различныхсимволов.
Не существует отрицательных значений типа char. Над переменными символьного типа допустимо выполнение арифметических операций.
Пример использования символьного типа данных:
	char ch1, ch2, ch3, ch4;
	int kod;
	int sum;
	ch1 = 'A';     // Записываем в переменную ch1 символ A
	ch2 = 65;      // переменной ch2 также присваивается символ A. Его Unicode код  равен 65 
	ch3 = 'B';     // Записываем в переменную ch3 символ B, его код 66
	ch4 = 'C';     // Записываем в переменную ch3 символ C, его код 67
	kod=(int)ch1;  //получаем код переменной по символу из Unicode-таблицы 
	System.out.println(ch1 + " " + ch2 + " "+ kod ); //будет выведено: A A 65
	// находим сумму
	sum =ch2 + ch3 + ch4;           // код: 65 + 66 + 67 = 198
	System.out.println(sum);        //будет выведено  198
	//по коду найдем символ
	System.out.println((char)sum);  //будет выведен символ E
 
Переменная f примет значение true потому, что  символ ch1 имеет код меньше чем символ ch3: ch1 расположен по алфавиту и в  Unicode-таблице также раньше символа ch3.

Примеры объявления числовых типов
	//объявление переменных типа byte.
	byte getByte, putByte;
	// инициализация переменных
	getByte = 0;
	putByte = 0;

	//объявление и инициализация переменной типа short.
	short employeeID = 0;
	
	//объявление и инициализация переменной типа int.
	int max = 2147483647;
 
Тип int используется чаще при работе с целочисленными данными, нежели byte и short, даже если их диапазона хватает. Это происходит потому, что при указании значений типа  byte и short  в выражениях, их тип все равно автоматически  повышается до int при вычислении.\

	//Использование переменных типа long.
	long days = getDays();
	long seconds;
	seconds = days * 24 * 60 * 60;
Тип удобен для работы с большими целыми числами.

	//Объявление и инициализация переменных типа float.
	float usd = 31.24f;
	float eur = 44.03f;
Удобен для использования, когда не требуется особой точности в дробной части числа.

	//Объявление и инициализация переменных типа double.
	double pi = 3.14159; 
Математические функции такие как sin(), cos(), sqrt() возвращают значение double

В Java также имеются константы. В отличие от переменных константам можно присвоить значение только один раз. Константа объявляется также, как и переменная, только вначале идет ключевое слово final:
	final int num=5;
	num=57; // так мы уже не можем написать, так как num - константа
Константы позволяют задать такие переменные, которые не должны больше изменяться. Например, если у нас есть переменная для хранения числа pi, то мы можем объявить ее константой, так как ее значение постоянно.


Операции над примитивными типами данных 

Знаки операций, аргументами которых являются числа, разделяются на две категории: унарные (unary) знаки операций с одним аргументом и бинарные (binary) с двумя аргументами.

	1. Операция присваивания
	
Присвоение переменной значения константы, другой переменной или выражения (переменных и/или констант, разделенных знаками операций), называется операцией присваивания и обозначается знаком "=", например:
	x = 3; y = x; z = x;
В Java допустимо многократное использование операции присваивания в одном выражении, например:
	x1 = x2 = x3 = 0;
Эта операция выполняется справа налево, т.е. сначала переменной x3 присваивается значение 0, затем переменной x2 присваивается значение переменной x3 (0), и, наконец, переменной x1 присваивается значение переменной x2 (0).

	2. Унарные операции
	
В Java определены следующие унарные операции: 
	- унарный минус "-" – меняет знак числа или выражения на противоположный;
	- унарный плюс "+" – не выполняет никаких действий над числом или выражением;
	- побитовое дополнение "~" (только для целых) – инвертирует все биты поля числа (меняет 0 на 1 и 1 на 0);
	- инкремент "++" (только для целых) – увеличивает значение переменной на 1;
	- декремент "--" (только для целых) – уменьшает значение переменной на 1.

Примеры унарных операций "+" и "-":
	int i = 3, j, k;
	j= -i; // j = -3
	k = +i; // k = 3

Пример операции побитового дополнения:
	int a = 15;
	int b;
	b = ~a; // b = -16
Числа a и b являются числами типа int, т.е. представляются внутри компьютера как двоичные целые числа со знаком длиной 32 бита, поэтому двоичное представление чисел a и b будет выглядеть следующим образом:
	a = 00000000 00000000 00000000 00001111
	b = 11111111 11111111 11111111 11110000

Знаки операции инкремента и декремента могут размещаться как до, так и после переменной. Эти варианты называются соответственно префиксной и постфиксной записью этих операции. Знак операции в префиксной записи возвращает значение своего операнда после вычисления выражения. При постфиксной записи знак операции сначала возвращает значение своего операнда и только после этого вычисляет инкремент или декремент, например:
	int x = 1, y, z;
	y = ++x;
	z=x++;
Переменной y будет присвоено значение 2, поскольку сначала значение x будет увеличено на 1, а затем результат будет присвоен переменной y. Переменной z будет присвоено значение 1, поскольку сначала переменной z будет присвоено значение, а затем значение x будет увеличено на 1. В обоих случаях новое значение переменной x будет равно 2.

	3. Бинарные арифметические операции
	
В Java определены следующие арифметические бинарные операции:
	- сложение "+";
	- вычитание "-";
	- умножение "*";
	- деление "/";
	- вычисление остатка от деления целых чисел "%" (возвращает остаток от деления первого числа на второе, причем результат будет иметь тот же знак, что и делимое), например, результат операции 5%3 будет равен 2, а результат операции (-7)%(-4) будет равен -3. В Java операция может использоваться и для вещественных переменных (типа float или double).

Примеры бинарных арифметических операций:
	int x = 7, x1, x2, x3, x4, x5;
	x1 = x +10; // x1 = 17
	x2 = x – 8; // x2 = -1
	x3 = x2 * x; // x3 = -7

	x4 = x/4; // x4 = 1 (при делении целых чисел
	// дробная часть отбрасывается)
	x5 = x%4 // x5 = 3 (остаток от деления
	// 7 на 4)

	4. Побитовые операции

Побитовые операции рассматривают исходные числовые значения как поля битов и выполняют над ними следующие действия:
	- установка бита в i-ой позиции поля результата в 1, если оба бита в i-ых позициях операндов равны 1, или в 0 в противном случае – побитовое И ("&");
	- установка бита в i-ой позиции поля результата в 1, если хотя бы один бит в i-ых позициях операндов равен 1, или в 0 в противном случае – побитовое ИЛИ ("|");
	- установка бита в i-ой позиции поля результата в 1, если биты в i-ых позициях операндов не равны друг другу, или в 0 в противном случае – побитовое исключающее ИЛИ ("^");
	- сдвиг влево битов поля первого операнда на количество битов, определяемое вторым операндом (бит знака числа при этом не меняется) – побитовый сдвиг влево с учетом знака "<<";
	- сдвиг вправо битов поля первого операнда на количество битов, определяемое вторым операндом (бит знака числа при этом не меняется) – побитовый сдвиг вправо с учетом знака ">>";
	- сдвиг вправо битов поля первого операнда на количество битов, определяемое вторым операндом (бит знака числа при этом также сдвигается) – побитовый сдвиг вправо без учета знака ">>>".

Примеры побитовых операций:
		4.1. Побитовое И
			int x = 112;
			// x: 00000000 00000000 00000000 01110000
			int y = 94;
			// y: 00000000 00000000 00000000 01011110
			int z;
			z = x & y;
			// z=80: 00000000 00000000 00000000 01010000

		4.2. Побитовое ИЛИ
			int x = 112;
			// x: 00000000 00000000 00000000 01110000
			int y = 94;
			// y: 00000000 00000000 00000000 01011110
			int z;
			z =x | y;
			// z = 126: 00000000 00000000 00000000 01111110

		4.3. Побитовое исключающее ИЛИ
			int x = 112;
			// x: 00000000 00000000 00000000 01110000
			int y = 94;
			// y: 00000000 00000000 00000000 01011110
			int z;
			z =x ^ y;
			// z = 46: 00000000 00000000 00000000 00101110

		4.4. Сдвиг влево с учетом знака
			int x = 31, z;
			// x: 00000000 00000000 00000000 00011111
			z = x << 2;
			// z = 124: 00000000 00000000 00000000 01111100

		4.5. Сдвиг вправо с учетом знака
			int x = -17, z;
			// x: 11111111 11111111 11111111 11101111
			z = x >> 2;
			// z = -5: 11111111 11111111 11111111 11111011

		4.6. Сдвиг вправо без учета знака
			int x = -17, z;
			// x: 11111111 11111111 11111111 11101111
			z = x >>> 2;
			// z = 1073741819
			// z: 00111111 11111111 11111111 11111011

	5. Комбинированные операции
В Java для бинарных арифметических операций можно использовать комбинированные (составные) знаки операций:
	идентификатор операция = выражение
Это эквивалентно следующей операции:
	идентификатор = идентификатор операция выражение
Примеры:
		5.1. Выражение x += b означает x = x + b.
		5.2. Выражение x -= b означает x = x — b.
		5.3. Выражение x *= b означает x = x * b.
		5.4. Выражение x /= b означает x = x / b.
		5.5. Выражение x %= b означает x = x % b.
		5.6. Выражение x &= b означает x = x & b.
		5.7. Выражение x |= b означает x = x | b.
		5.8. Выражение x ^= b означает x = x ^ b.
		5.9. Выражение x <<= b означает x = x << b.
		5.10. Выражение x >>= b означает x = x >> b.
		5.11. Выражение x >>>= b означает x = x >>> b.
		
	6. Операции сравнения
В Java определены следующие операции сравнения
	"==" (равно), "!=" (не равно),
	">" (больше), ">=" (больше или равно),
	"<" (меньше) "<=" (меньше или равно)
имеют два операнда и возвращают булевское значение, соответствующее результату сравнения (false или true). Следует обратить внимание, что при сравнении двух величин на равенство в Java, как и в C и в C++, используются символы "==" (два идущих без пробела друг за другом знака равенства), в отличие от оператора присваивания, в котором используется символ "=". Использование символа "=" при сравнении двух величин либо вызывает ошибку при компиляции, либо приводит к неверному результату.

Примеры операций сравнения:
	boolean isEqual, isNonEqual, isGreater,
	isGreaterOrEqual, isLess, isLessOrEqual;
	int x1 = 5, x2 = 5, x3 = 3, x4 = 7;
	isEqual = x1 == x2; // isEqual = true
	isNonEqual = x1 != x2; // isNonEqual = false
	isGreater = x1 > x3; // isGreater = true
	// isGreaterOrEqual = true
	isGreaterOrEqual = x2 >= x3;
	isLess = x3 < x1; // isLess = true
	isLessOrEqual = x1 <= x3; // isLessOrEqual = false
	
	7. Булевские операции
Булевские операции выполняются над булевскими переменными и их результатом также является значение типа boolean. В Java определены следующие булевские операции:
	- отрицание "!" – замена false на true, или наоборот;
	- операция И "&" – результат равен true, только, если оба операнда равны true, иначе результат – false;
	- операция ИЛИ "|" – результат равен true, только, если хотя бы один из операндов равен true, иначе результат – false.
	- операция исключающее ИЛИ "^" – результат равен true, только, если операнды не равны друг другу, иначе результат – false.

Операции "&", "|" и "^" можно, также как и соответствующие побитовые операции использовать в составных операциях присваивания: "&=", "|=" и "^="
Кроме того, к булевским операндам применимы операции "==" (равно) и "!=" (не равно).
Как видно из определения операций ИЛИ и И, операция ИЛИ приводит к результату true, когда первый операнд равен true, независимо от значения второго операнда, а операция И приводит к результату false, когда первый операнд равен false, независимо от значения второго операнда.
В Java определены еще две булевские операции: вторые версии булевских операций И и ИЛИ, известные как укороченные (short-circuit) логические операции: укороченное И "&&" и укороченное ИЛИ "||". При использовании этих операций второй операнд вообще не будет вычисляться, что полезно в тех случаях, когда правильное функционирование правого операнда зависит от того, имеет ли левый операнд значение true или false.

Примеры булевских операций:
	boolean isInRange, isValid, isNotValid,
	isEqual, isNotEqual;
	int x = 8;
	isInRange = x > 0 && x < 5; // isInRange = false
	isValid = x > 0 || x > 5; // isValid = true
	isNotValid = !isValid; // isNotValid = false
	isEqual = isInRange == isValid; // isEqual = false
	// isNotEqual = true
	isNotEqual = isInRange != isValid
	
	8. Условная операция
Условная операция записывается в форме
	выражение-1? выражение-2: выражение-3.
При этом сначала вычисляется выражение выражение-1, которое должно дать булевское значение, а затем, если выражение-1 имеет значение true, вычисляется и возвращается выражение-2 как результат выполнения операции, либо (если выражение-1 имеет значение false), вычисляется и, как результат выполнения операции, возвращается выражение-3.
Пример условной операции:
	x=n>1?0:1;
Переменной x будет присвоено значение 0, если n>1 (выражение n>1 имеет значение true) или 1, если n≤1 (выражение n>1 имеет значение false).


Ссылочные типы данных.

Тип String.

Тип String не является примитивным типом данных, однако это один из наиболее используемых типов в Java.  String  предназначен для хранения строк текста. Несколько примеров использования String
	//Создание строки с помощью конструктора 
	String myString = new String("The weather was fine");
	//Можно также создать строку используя кавычки ""
	String myString = "The weather was fine";
Для строк определен оператор «+»
	public static void main(String[] args) {
		String s1 = "I have ";
		String s2 = " apples ";
		int num = 3;
		String s = s1 + num + s2;
		System.out.println(s);
	}
Вывод программы:
	I have 3 apples 

В ссылочные типы входят все классы, интерфейсы, массивы. 
Также существуют классы-оболочки:
	Byte
	Short
	Integer
	Long
	Float
	Double
	Character
	Boolean
В отличие от примитивных типов, они пишутся с заглавной буквы. Эти типы соответствуют примитивным типам, однако являются ссылочными. Их классы cодержат методы для преобразования типов, а также другие константы и методы полезные при работе с примитивными типами данных.
В качестве типа также выступает любой созданный нами класс при создании инстанции класса.


Массивы.


Массив — это конечная последовательность упорядоченных элементов одного типа, доступ к каждому элементу в которой осуществляется по его индексу.
Размер или длина массива — это общее количество элементов в массиве. Размер массива задаётся при создании массива и не может быть изменён в дальнейшем, т. е. нельзя убрать элементы из массива или добавить их туда, но можно в существующие элементы присвоить новые значения.
Индекс начального элемента — 0, следующего за ним — 1 и т. д. Индекс последнего элемента в массиве — на единицу меньше, чем размер массива.
В Java массивы являются объектами. Это значит, что имя, которое даётся каждому массиву, лишь указывает на адрес какого-то фрагмента данных в памяти. Кроме адреса в этой переменной ничего не хранится. Индекс массива, фактически, указывает на то, насколько надо отступить от начального элемента массива в памяти, чтоб добраться до нужного элемента.
Чтобы создать массив надо объявить для него подходящее имя, а затем с этим именем связать нужный фрагмент памяти, где и будут друг за другом храниться значения элементов массива.
Возможные следующие варианты объявления массива:

	тип[] имя;
	тип  имя[];
Где тип — это тип элементов массива, а имя — уникальный (незанятый другими переменными или объектами в этой части программы) идентификатор, начинающийся с буквы.

Примеры:
	int[] a;
	double[] ar1;
	double  ar2[];
В примере мы объявили имена для трёх массивов. С первом именем a сможет быть далее связан массив из элементов типа int, а с именами ar1 и ar2 далее смогут быть связаны массивы из вещественных чисел (типа double). Пока мы не создали массивы, а только подготовили имена для них.
Теперь создать (или как ещё говорят инициализировать) массивы можно следующим образом:
	a = new int[10]; // массив  из 10 элементов типа int
	int n = 5;
	ar1 =  new double[n]; // Массив из 5 элементов double
	ar2 = {3.14, 2.71, 0, -2.5, 99.123}; // Массив из 6 элементов типа double
То есть при создании массива мы можем указать его размер, либо сразу перечислить через запятую все желаемые элементы в фигурных скобках (при этом размер будет вычислен автоматически на основе той последовательности элементов, которая будет указана).

Если массив был создан с помощью оператора new, то каждый его элемент получает значение по умолчанию. Каким оно будет определяется на основании типа данных (0 для int, 0.0 для double и т. д.).
Объявить имя для массива и создать сам массив можно было на одной строке по следующей схеме:
	тип[] имя  = new тип[размер];
	тип[] имя = {эл0, эл1, …, элN};
Примеры:
	int[] mas1 = {10,20,30};
	int[] mas2  = new int[3];
Чтобы обратиться к какому-то из элементов массива для того, чтобы прочитать или изменить его значение, нужно указать имя массива и за ним индекс элемента в квадратных скобках. Элемент массива с конкретным индексом ведёт себя также, как переменная. Например, чтобы вывести последний элемент массива mas1 мы должны написать в программе:
	System.out.println("Последний  элемент массива " + mas1[2]);
Длину любого созданного массива не обязательно запоминать, потому что имеется свойство, которое его хранит. Обратиться к этому свойству можно дописав .length к имени массива. Например:
	int razmer = mas1.length;
Это свойство нельзя изменять (т. е. ему нельзя ничего присваивать), можно только читать. Используя это свойство можно писать программный код для обработки массива даже не зная его конкретного размера.
Например, так можно вывести на экран элементы любого массива с именем ar2:
	for(int i = 0; i <= ar2.length  - 1; i++) {
	System.out.print(ar2[i] + "  ");
	}
	
Многомерные массивы

Массив может состоять не только из элементов какого-то встроенного типа (int, double и пр.), но и, в том числе, из объектов какого-то существующего класса и даже из других массивов.
Массив который в качестве своих элементов содержит другие массивы называется многомерным массивом.
Чаще всего используются двумерные массивы. Такие массивы можно легко представить в виде матрицы. Каждая строка которой является обычным одномерным массивом, а объединение всех строк — двумерным массивом в каждом элементе которого хранится ссылка на какую-то строку матрицы.
Трёхмерный массив можно представить себе как набор матриц, каждую из которых мы записали на библиотечной карточке. Тогда чтобы добраться до конкретного числа сначала нужно указать номер карточки (первый индекс трёхмерного массива), потому указать номер строки (второй индекс массива) и только затем номер элемент в строке (третий индекс).
Соответственно, для того, чтобы обратиться к элементу n-мерного массива нужно указать n индексов.
Объявляются массивы так:
	int[] d1; //Обычный, одномерный
	int[][] d2; //Двумерный
	double[][] d3; //Трёхмерный
	int[][][][][] d5; //Пятимерный
При создании массива можно указать явно размер каждого его уровня:
	d2 = int[3][4]; // Матрица  из 3 строк и 4 столбцов
Но можно указать только размер первого уровня:
	int[][] dd2 =  int[5][]; /* Матрица из 5 строк. Сколько элементов будет в каждой строке пока не известно. */
В последнем случае, можно создать двумерный массив, который не будет являться матрицей из-за того, что в каждой его строке будет разное количество элементов. Например:
	for(int i=0; i<5; i++) {
	  dd2[i] = new int[i+2];
	}
В результате получим такой вот массив:
	0 0
	0 0 0
	0 0 0 0
	0 0 0 0 0
	0 0 0 0 0 0
Мы могли создать массив явно указав его элементы. Например так:
	int[][] ddd2 = {{1,2}, {1,2,3,4,5}, {1,2,3}};
При этом можно обратиться к элементу с индексом 4 во второй строке ddd2[1][4], но если мы обратимся к элементу ddd2[0][4] или ddd2[2][4] — произойдёт ошибка, поскольку таких элементов просто нет. Притом ошибка это будет происходить уже во время исполнения программы (т. е. компилятор её не увидит).
